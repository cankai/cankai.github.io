<!DOCTYPE html>
<html lang="zh">
<head>

        <title>排序</title>
        <meta charset="utf-8" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="/theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="/theme/style.css" />
        <link rel="stylesheet" type="text/css" href="/theme/pygment.css" />

        <script src="/theme/js/libs/modernizr-2.6.2.min.js"></script>




</head>

<body id="index" class="home">


    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="/">Chen Kai's land. <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>
             
              <ul class="columns">
                <li><a href="/">Home</a></li>


              </ul>
            </div>

<section id="content" class="body">

   <div class="row">
        <div class="eleven columns">


            <header>
              <h2 class="entry-title">
                <a href="/sort.html" rel="bookmark"
                   title="Permalink to 排序">排序</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2017-08-15T22:40:00+08:00">
                2017-08-15 22:40:00
              </abbr>
              <address class="vcard author">By 
                <a class="url fn" href="/author/chen-kai.html"> Chen Kai</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <p>Summary: 排序是对数据的最基本操作，一个快速的排序经常对程序的效率产生重要影响，下面对不同的排序方法进行比较。</p>
<h3>1、选择排序</h3>
<p>选择排序是最简单，最直接的一种排序算法，起算法逻辑是，首先选出最小的一个元素，与数组的第一个元素交换，然后选出剩下数组中最小的，与剩下数组中的第一个元素交换，一路递归，当最后剩下一个元素的时候，算法接收。</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">findMin</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">min</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">v1</span><span class="p">;</span>
    <span class="o">*</span><span class="n">v1</span> <span class="o">=</span> <span class="o">*</span><span class="n">v2</span><span class="p">;</span>
    <span class="o">*</span><span class="n">v2</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">selectionSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//find the min</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">findMin</span><span class="p">(</span><span class="n">arr</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
        <span class="c1">//exchange </span>
        <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">arr</span><span class="o">+</span><span class="n">min</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">selectionSort2</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">findMin</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">arr</span><span class="o">+</span><span class="n">min</span><span class="p">);</span>
    <span class="n">selectionSort</span><span class="p">(</span><span class="n">arr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>由代码可见，选择排序是一种稳定的排序方式，算法复杂度为O(n2)</p>
<h3>2、插入排序</h3>
<p>插入排序的操作方式类似于打扑克牌的时候抓牌进行的操作，拿出一张牌，把它放到正确的位置，因此插入排序又叫做扑克牌排序。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">insertionSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//类似于扑克牌排序，手中的牌是已经排好序的，来一个牌，则将牌插到正确位置</span>
    <span class="c1">//1，找到正确位置，将位置后面的数依次后移，然后将牌放入空位</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//[0,i]是已经排序的，arr[i+1]带插入数值</span>
        <span class="kt">int</span> <span class="n">key_val</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>3、冒泡排序</h3>
<p>冒泡排序通过比较相邻元素的大小并交换来冒出最大值，每一轮冒出一个值，通过n轮循环，即可排序</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//j代表数组冒泡出来的元素</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">arr</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>4、快速排序</h3>
<p>快速排序利用了分治的思想，先将数组按照一个key 分为两部分，右边比key小于等于，左边大于key，那么此次key 的位置为最终位置，然后依次对左右递归，当数组只有一个元素的时候，递归结束。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">quickSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">//设置key为关键值，大于key的位于key一边，小于key的位于另外一边</span>
        <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//分割线，[0,last]小于key，(last,i)大于key，[i,n]待比较</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">)</span>
                <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="o">++</span><span class="n">last</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">+</span><span class="n">last</span><span class="p">);</span>
        <span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
        <span class="n">quickSort</span><span class="p">(</span><span class="n">arr</span><span class="o">+</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">last</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>5、二分排序</h3>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr1</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arr2</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//arr1 和 arr2 相邻</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">n1</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tmp1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="n">n2</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tmp2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="p">;)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tmp1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tmp2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="p">{</span>
            <span class="n">arr1</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">arr1</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp2</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="o">++</span><span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n1</span><span class="p">)</span><span class="c1">//cp last to array</span>
    <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">arr1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="p">)</span><span class="c1">//cp last to array</span>
    <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">arr1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp2</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="o">++</span><span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">tmp1</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">tmp2</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//把arr均分为两部分，对两部分分别排序，再将排序的结果合并</span>
    <span class="c1">//当 n &lt;= 1的时候返回</span>
    <span class="c1">//fprintf(stderr, &quot;%d %p\n&quot;,n, arr);</span>
    <span class="c1">//printArray(arr, n);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="o">+</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">arr</span><span class="o">+</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//printf(&quot;after:&quot;);</span>
    <span class="c1">//printArray(arr, n);</span>
<span class="p">}</span>
</pre></div>


<h3>6、堆排序</h3>
<p>堆排序利用了堆数据结构，一个堆是一个完全二叉树，堆一般分为两种，大顶堆与小顶堆，大顶堆表示一个节点的值大于或等于它的子节点的值。小顶堆相反。所以，大顶堆得最大值为根节点。堆排序的过程是：1、建立一个大顶堆，然后交换根节点与最后一个节点，再恢复大顶堆，依次递归，当大顶堆元素个数为1 的时候，结束递归。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">max_heap_down</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">l</span><span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//从左右孩子中间选择一个较大的作为比较值</span>
        <span class="c1">//l 表示较大的值得索引</span>
        <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">l</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">heapSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//对于heap sort, 通过 parant to get left son and right son,lson=p*2+1, rson=p*2+2;</span>
    <span class="c1">//get parant, p=(son-1)/2</span>
    <span class="c1">//首先建立一个大顶堆，然后交换根节点和最后，然后进行堆恢复，再次交换，恢复</span>
    <span class="c1">//build a heap</span>
    <span class="c1">//i = n/2 - 1 为最后一个父节点索引位置</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">max_heap_down</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">max_heap_down</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">i</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
            </div><!-- /.entry-content -->


        </div><!-- /.eleven.columns -->

<div class="three columns">

<h4>Pages</h4>

 <ul>
  </ul>

<h4>Categories</h4>
<ul class="blank">
		<li><a href="/category/linux.html">Linux</a></li>
		<li><a href="/category/suan-fa.html">算法</a></li>
		<li><a href="/category/suan-fa-shu-ju-jie-gou.html">算法,数据结构</a></li>
		<li><a href="/category/wang-luo.html">网络</a></li>
</ul>


<h4>Tags</h4>
	<ul class="blank">
</ul>



</div> </div><!-- /.row -->


</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">





              </ul>
            </div>
          </div>
        </footer>

    </div>


  <script src="/theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="/theme/js/libs/gumby.min.js"></script>
  <script src="/theme/js/plugins.js"></script>
</body>
</html>